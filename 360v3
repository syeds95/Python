CREATE OR REPLACE VIEW ANL_LINES AS
WITH base AS (
  SELECT
    i.PatientID,
    i.OrderNumber,
    i.HCPCS,
    CAST(i.ServiceDateOfOrder AS DATE)     AS order_date,
    CAST(i.TotalAmount       AS NUMBER(38,2)) AS total_amount,
    CAST(i.TotalQTY          AS NUMBER(38,0)) AS qty,
    CAST(i.SupplyDuration    AS NUMBER(10,0)) AS supply_days,
    i.Patient_Group                           AS channel,      -- DTC / LINK
    i.Item_Group                               AS Item_Group,  -- Ostomy / Urology
    i.InsuranceName,
    h.header_next_elig
  FROM ORDER_ITEMS i
  LEFT JOIN ORDER_HEADER h USING (OrderNumber)
),
order_semantics AS (
  SELECT
    OrderNumber,
    COUNT(*)          AS rows_in_order,
    MIN(total_amount) AS min_amt,
    MAX(total_amount) AS max_amt
  FROM base
  GROUP BY 1
)
SELECT
  b.*,
  /* Ensure both CASE branches are NUMBER(38,2) */
  CAST(
    CASE
      WHEN os.rows_in_order > 1 AND os.min_amt = os.max_amt
        THEN b.total_amount / NULLIF(os.rows_in_order, 0)
      ELSE b.total_amount
    END
    AS NUMBER(38,2)
  ) AS line_amount_robust
FROM base b
JOIN order_semantics os USING (OrderNumber);






CREATE OR REPLACE TABLE ANL_HAZARD_PROBS_INS AS
SELECT
  channel, Item_Group, InsuranceName, bucket,
  (cnt::FLOAT) / NULLIF(total_cnt::FLOAT, 0.0) AS prob
FROM ANL_HAZARD_COUNTS_INS
WHERE bucket IN ('On-time (-7..+7)', 'Late (8..30)', 'Late (31..60)', 'Late (61..90)');

CREATE OR REPLACE TABLE ANL_HAZARD_PROBS_SEG AS
SELECT
  channel, Item_Group, bucket,
  (cnt::FLOAT) / NULLIF(total_cnt::FLOAT, 0.0) AS prob
FROM ANL_HAZARD_COUNTS_SEG
WHERE bucket IN ('On-time (-7..+7)', 'Late (8..30)', 'Late (31..60)', 'Late (61..90)');











CREATE OR REPLACE TABLE ANL_SEGMENT_AOV_INS AS
SELECT
  channel, Item_Group, InsuranceName,
  CAST(SUM(event_revenue) / NULLIF(COUNT(*), 0) AS NUMBER(38,2)) AS aov_event
FROM ANL_EVENTS
GROUP BY 1,2,3;

CREATE OR REPLACE TABLE ANL_SEGMENT_AOV_SEG AS
SELECT
  channel, Item_Group,
  CAST(SUM(event_revenue) / NULLIF(COUNT(*), 0) AS NUMBER(38,2)) AS aov_event
FROM ANL_EVENTS
GROUP BY 1,2;










CREATE OR REPLACE TABLE ANL_PATIENT_PREDICTIONS AS
WITH ds_ins AS (
  SELECT
    channel, Item_Group, InsuranceName,
    CAST(ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY delta_vs_elig)) AS NUMBER(10,0)) AS p50_delay,
    COUNT(*) AS n_pairs
  FROM ANL_REORDER_PAIRS
  WHERE delta_vs_elig IS NOT NULL
  GROUP BY 1,2,3
),
ds_seg AS (
  SELECT
    channel, Item_Group,
    CAST(ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY delta_vs_elig)) AS NUMBER(10,0)) AS p50_delay_default
  FROM ANL_REORDER_PAIRS
  WHERE delta_vs_elig IS NOT NULL
  GROUP BY 1,2
)
SELECT
  c.PatientID,
  c.channel,
  c.Item_Group,
  c.InsuranceName,
  c.last_order_date,
  c.next_elig_date,
  DATEADD(
    'day',
    COALESCE(
      CASE WHEN dsi.n_pairs >= $MIN_DELAY_N THEN dsi.p50_delay END,
      dss.p50_delay_default,
      0::NUMBER(10,0)
    ),
    c.next_elig_date
  ) AS predicted_next_ServiceDateOfOrder
FROM ANL_PATIENT_LATEST c
LEFT JOIN ds_ins dsi ON dsi.channel=c.channel AND dsi.Item_Group=c.Item_Group AND dsi.InsuranceName=c.InsuranceName
LEFT JOIN ds_seg dss ON dss.channel=c.channel AND dss.Item_Group=c.Item_Group;








/* OFFSETS, ELIG, HAZ_INS, HAZ_SEG same as before */

-- PARTICLES: ensure prob is FLOAT (not DECIMAL vs 0)
WITH OFFSETS AS (
  SELECT * FROM (
    VALUES ('On-time (-7..+7)', 0), ('Late (8..30)', 19), ('Late (31..60)', 45), ('Late (61..90)', 75)
  ) AS v(bucket, offset_days)
),
ELIG AS (
  SELECT PatientID, channel, Item_Group, InsuranceName, next_elig_date
  FROM ANL_PATIENT_LATEST
  WHERE next_elig_date IS NOT NULL
    AND next_elig_date >  $AS_OF_DATE
    AND next_elig_date <= DATEADD('day', $HORIZON_DAYS, $AS_OF_DATE)
),
HAZ_INS AS (SELECT channel, Item_Group, InsuranceName, bucket, prob FROM ANL_HAZARD_PROBS_INS),
HAZ_SEG AS (SELECT channel, Item_Group, bucket, prob FROM ANL_HAZARD_PROBS_SEG),
PARTICLES AS (
  SELECT
    e.channel,
    e.Item_Group,
    e.InsuranceName,
    DATEADD('day', off.offset_days, e.next_elig_date) AS expected_date,
    COALESCE(hi.prob, hs.prob, 0.0)                   AS prob    -- << float literal
  FROM ELIG e
  JOIN OFFSETS off ON 1=1
  LEFT JOIN HAZ_INS hi
    ON hi.channel=e.channel AND hi.Item_Group=e.Item_Group AND hi.InsuranceName=e.InsuranceName AND hi.bucket = off.bucket
  LEFT JOIN HAZ_SEG hs
    ON hs.channel=e.channel AND hs.Item_Group=e.Item_Group AND hs.bucket = off.bucket
  WHERE DATEADD('day', off.offset_days, e.next_elig_date) >  $AS_OF_DATE
    AND DATEADD('day', off.offset_days, e.next_elig_date) <= DATEADD('day', $HORIZON_DAYS, $AS_OF_DATE)
),
AOV_INS AS (SELECT channel, Item_Group, InsuranceName, aov_event FROM ANL_SEGMENT_AOV_INS),
AOV_SEG AS (SELECT channel, Item_Group, aov_event FROM ANL_SEGMENT_AOV_SEG)

CREATE OR REPLACE TABLE ANL_FORECAST_MONTHLY AS
SELECT
  DATE_TRUNC('month', p.expected_date)                                             AS forecast_month,
  p.channel,
  p.Item_Group,
  p.InsuranceName,
  SUM(p.prob)                                                                      AS expected_orders,
  SUM(p.prob * COALESCE(ai.aov_event, asg.aov_event, 0::NUMBER(38,2)))            AS expected_revenue  -- << typed 0
FROM PARTICLES p
LEFT JOIN AOV_INS ai
  ON ai.channel=p.channel AND ai.Item_Group=p.Item_Group AND ai.InsuranceName=p.InsuranceName
LEFT JOIN AOV_SEG asg
  ON asg.channel=p.channel AND asg.Item_Group=p.Item_Group
GROUP BY 1,2,3,4
ORDER BY forecast_month, channel, Item_Group, InsuranceName;







-- Unique-patient pipeline (no double count across products)
WITH last_order AS (
  SELECT PatientID, MAX(order_date) AS last_order_date
  FROM ORDER_HEADER
  GROUP BY 1
),
current AS (
  SELECT h.PatientID, h.channel, h.InsuranceName, h.header_next_elig
  FROM ORDER_HEADER h
  JOIN last_order lo
    ON lo.PatientID = h.PatientID AND lo.last_order_date = h.order_date
)
SELECT
  channel,
  InsuranceName,
  COUNT_IF(header_next_elig > $AS_OF_DATE AND header_next_elig <= DATEADD('day', 30, $AS_OF_DATE)) AS patients_elig_next_30,
  COUNT_IF(header_next_elig > $AS_OF_DATE AND header_next_elig <= DATEADD('day', 60, $AS_OF_DATE)) AS patients_elig_next_60,
  COUNT_IF(header_next_elig > $AS_OF_DATE AND header_next_elig <= DATEADD('day', 90, $AS_OF_DATE)) AS patients_elig_next_90
FROM current
GROUP BY 1,2
ORDER BY 1,2;
