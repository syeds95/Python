/* ===========================================================
   MONTHLY_REORDER_BEHAVIOR
   - Anchored on the month of the reorder (order_month)
   - Metrics by Channel Ã— Item_Group
   =========================================================== */

CREATE OR REPLACE TABLE MONTHLY_REORDER_BEHAVIOR (
  order_month                    DATE,
  channel                        VARCHAR,
  Item_Group                     VARCHAR,
  total_orders                   NUMBER(38,0),
  reorder_orders                 NUMBER(38,0),
  reorder_share_pct              NUMBER(5,1),
  reorder_patients               NUMBER(38,0),
  median_days_since_prior        NUMBER(10,1),
  median_days_between_orders     NUMBER(10,1),
  median_delta_vs_eligibility    NUMBER(10,1),
  early_pct                      NUMBER(5,1),
  on_time_pct                    NUMBER(5,1),
  late_8_30_pct                  NUMBER(5,1),
  late_31_60_pct                 NUMBER(5,1),
  late_61_90_pct                 NUMBER(5,1),
  late_gt_90_pct                 NUMBER(5,1),
  skipped_cycle_pct              NUMBER(5,1),
  cycle_index_median             NUMBER(10,2),
  reorder_aov                    NUMBER(38,2)
);

INSERT OVERWRITE INTO MONTHLY_REORDER_BEHAVIOR
WITH ev AS (
  /* Classify each order event as first vs reorder; compute prev order & prev supply */
  SELECT
    e.PatientID,
    e.channel,
    e.Item_Group,
    e.order_date,
    DATE_TRUNC('month', e.order_date) AS order_month,
    e.event_revenue,
    e.event_supply_days,
    LAG(e.order_date)       OVER (PARTITION BY e.PatientID, e.Item_Group ORDER BY e.order_date) AS prev_order_date,
    LAG(e.event_supply_days)OVER (PARTITION BY e.PatientID, e.Item_Group ORDER BY e.order_date) AS prev_supply_days,
    CASE WHEN LAG(e.order_date) OVER (PARTITION BY e.PatientID, e.Item_Group ORDER BY e.order_date) IS NOT NULL THEN 1 ELSE 0 END AS is_reorder
  FROM ANL_EVENTS e
),
re AS (
  SELECT
    order_month, channel, Item_Group, PatientID, event_revenue,
    DATEDIFF('day', prev_order_date, order_date)                           AS days_since_prior,
    (DATEDIFF('day', prev_order_date, order_date) / NULLIF(prev_supply_days, 0)) AS cycle_index
  FROM ev
  WHERE is_reorder = 1
),
totals AS (
  /* Totals & reorder counts; reorder AOV; recency & cycle stats (reorders only) */
  SELECT
    DATE_TRUNC('month', e.order_date)                                      AS order_month,
    e.channel,
    e.Item_Group,
    COUNT(*)                                                                AS total_orders,
    COUNT_IF(ev.is_reorder = 1)                                             AS reorder_orders,
    COUNT(DISTINCT CASE WHEN ev.is_reorder = 1 THEN e.PatientID END)        AS reorder_patients,
    /* Reorder AOV */
    CAST(SUM(CASE WHEN ev.is_reorder = 1 THEN e.event_revenue ELSE 0 END)
         / NULLIF(COUNT_IF(ev.is_reorder = 1), 0) AS NUMBER(38,2))          AS reorder_aov,
    /* Medians among reorders */
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY re.days_since_prior), 1)    AS median_days_since_prior,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY re.cycle_index), 2)         AS cycle_index_median,
    ROUND(100.0 * AVG(CASE WHEN re.cycle_index >= 1.5 THEN 1 ELSE 0 END), 1)      AS skipped_cycle_pct
  FROM ANL_EVENTS e
  JOIN ev ON ev.PatientID = e.PatientID AND ev.Item_Group = e.Item_Group AND ev.order_date = e.order_date
  LEFT JOIN re ON re.order_month = DATE_TRUNC('month', e.order_date) AND re.channel=e.channel AND re.Item_Group=e.Item_Group AND re.PatientID=e.PatientID
  GROUP BY 1,2,3
),
timeliness AS (
  /* Timeliness distribution & medians, anchored on the month the reorder happened */
  SELECT
    DATE_TRUNC('month', next_order_date)                                     AS order_month,
    channel,
    Item_Group,
    COUNT(*)                                                                 AS reorders_in_month,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY days_to_next), 1)      AS median_days_between_orders,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY delta_vs_elig), 1)     AS median_delta_vs_eligibility,
    ROUND(100.0 * AVG(CASE WHEN delta_vs_elig < -7 THEN 1 ELSE 0 END), 1)    AS early_pct,
    ROUND(100.0 * AVG(CASE WHEN ABS(delta_vs_elig) <= 7 THEN 1 ELSE 0 END), 1) AS on_time_pct,
    ROUND(100.0 * AVG(CASE WHEN delta_vs_elig BETWEEN 8 AND 30 THEN 1 ELSE 0 END), 1)   AS late_8_30_pct,
    ROUND(100.0 * AVG(CASE WHEN delta_vs_elig BETWEEN 31 AND 60 THEN 1 ELSE 0 END), 1)  AS late_31_60_pct,
    ROUND(100.0 * AVG(CASE WHEN delta_vs_elig BETWEEN 61 AND 90 THEN 1 ELSE 0 END), 1)  AS late_61_90_pct,
    ROUND(100.0 * AVG(CASE WHEN delta_vs_elig > 90 THEN 1 ELSE 0 END), 1)               AS late_gt_90_pct
  FROM ANL_REORDER_PAIRS
  WHERE next_order_date IS NOT NULL
  GROUP BY 1,2,3
)
SELECT
  t.order_month,
  t.channel,
  t.Item_Group,
  t.total_orders,
  t.reorder_orders,
  ROUND(100.0 * (t.reorder_orders::FLOAT) / NULLIF(t.total_orders::FLOAT, 0.0), 1) AS reorder_share_pct,
  t.reorder_patients,
  t.median_days_since_prior,
  tm.median_days_between_orders,
  tm.median_delta_vs_eligibility,
  tm.early_pct,
  tm.on_time_pct,
  tm.late_8_30_pct,
  tm.late_31_60_pct,
  tm.late_61_90_pct,
  tm.late_gt_90_pct,
  t.skipped_cycle_pct,
  t.cycle_index_median,
  t.reorder_aov
FROM totals t
LEFT JOIN timeliness tm
  ON tm.order_month = t.order_month AND tm.channel = t.channel AND tm.Item_Group = t.Item_Group
ORDER BY t.order_month, t.channel, t.Item_Group;
