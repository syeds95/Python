-- hme_key_metrics.sql
-- Patient-Level & Aggregate Behavior Analysis converted from pandas to pure SQL

-- Source Data CTE: replace this with your original SQL script to retrieve the ORDERS-like data
-- e.g., SELECT * FROM your_source_table WHERE ...
, source_data AS (
  -- Paste your original SQL here to define the base dataset with the required columns
  SELECT * FROM ORDERS  -- << replace with your source query >>
)

-- 1. Descriptive patient attributes (RFM + tenure + static attrs)  
WITH descriptive AS (
  SELECT
    PATIENTID,
    MIN(SERVICEDATEOFORDER) AS FIRST_SERVICE_DATE,
    MAX(SERVICEDATEOFORDER) AS LAST_SERVICE_DATE,
    COUNT(DISTINCT ORDERNUMBER) AS ORDERS_TOTAL,
    SUM(TOTALAMOUNT)          AS TOTAL_REVENUE,
    SUM(TOTALQTY)             AS TOTAL_QTY,
    -- static attrs: pick most recent via MAX_BY
    MAX_BY(INSURANCE, SERVICEDATEOFORDER)    AS INSURANCE,
    MAX_BY(PATIENT_GROUP, SERVICEDATEOFORDER) AS PATIENT_GROUP,
    MAX_BY(ITEM_GROUP, SERVICEDATEOFORDER)    AS ITEM_GROUP
  FROM source_data
  GROUP BY PATIENTID
),
WITH descriptive AS (
  SELECT
    PATIENTID,
    MIN(SERVICEDATEOFORDER) AS FIRST_SERVICE_DATE,
    MAX(SERVICEDATEOFORDER) AS LAST_SERVICE_DATE,
    COUNT(DISTINCT ORDERNUMBER) AS ORDERS_TOTAL,
    SUM(TOTALAMOUNT)          AS TOTAL_REVENUE,
    SUM(TOTALQTY)             AS TOTAL_QTY,
    -- static attrs: pick most recent via MAX_BY
    MAX_BY(INSURANCE, SERVICEDATEOFORDER)    AS INSURANCE,
    MAX_BY(PATIENT_GROUP, SERVICEDATEOFORDER) AS PATIENT_GROUP,
    MAX_BY(ITEM_GROUP, SERVICEDATEOFORDER)    AS ITEM_GROUP
  FROM ORDERS
  GROUP BY PATIENTID
),

-- 2. Order-level intervals & on-time flags
order_intervals AS (
  SELECT
    o.PATIENTID,
    o.ORDERNUMBER,
    o.SERVICEDATEOFORDER,
    LAG(o.SERVICEDATEOFORDER) OVER (PARTITION BY o.PATIENTID ORDER BY o.SERVICEDATEOFORDER) AS PREV_DATE,
    LAG(o.ELIGIBLETOSHIP)   OVER (PARTITION BY o.PATIENTID ORDER BY o.SERVICEDATEOFORDER) AS PREV_ELIGIBLE,
    o.SUPPLYDURATION,
    o.TOTALAMOUNT,
    -- filter out first orders in next step
    DATEDIFF('day', LAG(o.SERVICEDATEOFORDER) OVER (PARTITION BY o.PATIENTID ORDER BY o.SERVICEDATEOFORDER),
                       o.SERVICEDATEOFORDER)            AS DAYS_BETWEEN,
    DATEDIFF('day', LAG(o.ELIGIBLETOSHIP) OVER (PARTITION BY o.PATIENTID ORDER BY o.SERVICEDATEOFORDER),
                       o.SERVICEDATEOFORDER)            AS DAYS_AFTER_ELIGIBLE,
    CASE WHEN DATEDIFF('day', LAG(o.ELIGIBLETOSHIP) OVER (PARTITION BY o.PATIENTID ORDER BY o.SERVICEDATEOFORDER),
                         o.SERVICEDATEOFORDER) BETWEEN 0 AND o.SUPPLYDURATION * 0.1
         THEN 1 ELSE 0 END                                 AS ON_TIME_FLAG
  FROM ORDERS o
),

-- 3. Aggregate order-level metrics per patient
order_metrics AS (
  SELECT
    PATIENTID,
    AVG(DAYS_BETWEEN)      AS AVG_DAYS_BETWEEN,
    AVG(CASE WHEN DAYS_AFTER_ELIGIBLE > 0 THEN DAYS_AFTER_ELIGIBLE ELSE NULL END) AS AVG_DAYS_LATE,
    SUM(ON_TIME_FLAG)      AS ON_TIME_ORDERS,
    COUNT(ORDERNUMBER)     AS TOTAL_ORDERS,
    SUM(TOTALAMOUNT)       AS REVENUE_ORDERS
  FROM order_intervals
  WHERE PREV_DATE IS NOT NULL
  GROUP BY PATIENTID
),

-- 4. Churn flag based on last supply duration
last_supply AS (
  SELECT PATIENTID, MAX(SUPPLYDURATION) AS LAST_SUPPLY_DURATION
  FROM ORDERS
  GROUP BY PATIENTID
),
churn AS (
  SELECT
    d.PATIENTID,
    CASE WHEN DATEDIFF('day', d.LAST_SERVICE_DATE, CURRENT_DATE()) > ls.LAST_SUPPLY_DURATION * 1.1
         THEN 1 ELSE 0 END AS CHURN_FLAG
  FROM descriptive d
  LEFT JOIN last_supply ls USING(PATIENTID)
),

-- 5. Time to first reorder
second_order AS (
  SELECT PATIENTID, MIN(SERVICEDATEOFORDER) KEEP (DENSE_RANK SECOND ORDER BY SERVICEDATEOFORDER) AS SECOND_DATE
  FROM ORDERS
  GROUP BY PATIENTID
),
time_to_first AS (
  SELECT
    d.PATIENTID,
    DATEDIFF('day', d.FIRST_SERVICE_DATE, so.SECOND_DATE) AS TIME_TO_FIRST_REORDER
  FROM descriptive d
  LEFT JOIN second_order so USING(PATIENTID)
),

-- 6. LTV curves
ltv_prep AS (
  SELECT
    o.PATIENTID,
    o.SERVICEDATEOFORDER,
    o.TOTALAMOUNT,
    d.FIRST_SERVICE_DATE
  FROM ORDERS o
  JOIN descriptive d USING(PATIENTID)
),
ltv AS (
  SELECT
    PATIENTID,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <=  30 THEN TOTALAMOUNT ELSE 0 END) AS LTV_30d,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <=  60 THEN TOTALAMOUNT ELSE 0 END) AS LTV_60d,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <=  90 THEN TOTALAMOUNT ELSE 0 END) AS LTV_90d,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <= 180 THEN TOTALAMOUNT ELSE 0 END) AS LTV_180d,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <= 365 THEN TOTALAMOUNT ELSE 0 END) AS LTV_365d
  FROM ltv_prep
  GROUP BY PATIENTID
),

-- 7. Basket composition
distinct_items AS (
  SELECT PATIENTID, COUNT(DISTINCT HCPCS) AS UNIQUE_HCPCS
  FROM ORDERS
  GROUP BY PATIENTID
),

-- 8. Seasonality
distinct_months AS (
  SELECT PATIENTID, COUNT(DISTINCT DATE_TRUNC('month', SERVICEDATEOFORDER)) AS ACTIVE_MONTHS
  FROM ORDERS
  GROUP BY PATIENTID
),

-- 9. Assemble final patient metrics
patient_metrics AS (
  SELECT
    d.PATIENTID,
    INSURANCE,
    PATIENT_GROUP,
    ITEM_GROUP,
    d.FIRST_SERVICE_DATE,
    d.LAST_SERVICE_DATE,
    DATEDIFF('day', d.FIRST_SERVICE_DATE, CURRENT_DATE()) AS TENURE_DAYS,
    DATEDIFF('day', d.LAST_SERVICE_DATE,  CURRENT_DATE()) AS RECENCY_DAYS,
    d.ORDERS_TOTAL,
    d.TOTAL_REVENUE,
    d.TOTAL_QTY,
    om.AVG_DAYS_BETWEEN,
    om.AVG_DAYS_LATE,
    om.ON_TIME_ORDERS,
    om.TOTAL_ORDERS,
    om.REVENUE_ORDERS,
    CASE WHEN om.TOTAL_ORDERS > 0 THEN om.ON_TIME_ORDERS / om.TOTAL_ORDERS ELSE 0 END AS ON_TIME_RATE,
    c.CHURN_FLAG,
    tf.TIME_TO_FIRST_REORDER,
    l.*,
    di.UNIQUE_HCPCS,
    dm.ACTIVE_MONTHS
  FROM descriptive d
  LEFT JOIN order_metrics om USING(PATIENTID)
  LEFT JOIN churn c USING(PATIENTID)
  LEFT JOIN time_to_first tf USING(PATIENTID)
  LEFT JOIN ltv l USING(PATIENTID)
  LEFT JOIN distinct_items di USING(PATIENTID)
  LEFT JOIN distinct_months dm USING(PATIENTID)
)

-- 10. Create final table
CREATE OR REPLACE TABLE PATIENT_BEHAVIOR_METRICS AS
SELECT *,
  CASE
    WHEN AVG_DAYS_LATE <=  3 THEN '0-3 days late'
    WHEN AVG_DAYS_LATE <=  7 THEN '4-7 days late'
    WHEN AVG_DAYS_LATE <= 14 THEN '8-14 days late'
    WHEN AVG_DAYS_LATE <= 30 THEN '15-30 days late'
    WHEN AVG_DAYS_LATE <= 60 THEN '31-60 days late'
    WHEN AVG_DAYS_LATE <= 90 THEN '61-90 days late'
    ELSE '>90 days late'
  END AS DAYS_LATE_BUCKET
FROM patient_metrics;

-- 11. Monthly behavior trends (last 24 months)
CREATE OR REPLACE TABLE MONTHLY_BEHAVIOR_TRENDS AS
SELECT
  DATE_TRUNC('month', o.SERVICEDATEOFORDER) AS MONTH,
  COUNT(DISTINCT o.PATIENTID) AS ACTIVE_PATIENTS,
  COUNT(o.ORDERNUMBER)        AS TOTAL_ORDERS,
  AVG(DATEDIFF('day', prev.PREV_ELIGIBLE, o.SERVICEDATEOFORDER)) AS AVG_DAYS_LATE,
  SUM(CASE WHEN
        DATEDIFF('day', prev.PREV_ELIGIBLE, o.SERVICEDATEOFORDER) BETWEEN 0 AND o.SUPPLYDURATION*0.1
        THEN 1 ELSE 0 END)::DOUBLE / COUNT(*) AS ON_TIME_RATE,
  SUM(o.TOTALAMOUNT) AS TOTAL_REVENUE
FROM ORDER_INTERRUPTED prev  -- see CTE below
JOIN ORDERS o ON prev.ORDERNUMBER = o.ORDERNUMBER
WHERE o.SERVICEDATEOFORDER >= DATEADD(month, -24, CURRENT_DATE())
GROUP BY 1
ORDER BY 1;

-- Helper CTE for prev eligible in monthly trends
WITH ORDER_INTERRUPTED AS (
  SELECT
    ORDERNUMBER,
    PATIENTID,
    LAG(ELIGIBLETOSHIP) OVER (PARTITION BY PATIENTID ORDER BY SERVICEDATEOFORDER) AS PREV_ELIGIBLE
  FROM ORDERS
)
```
