-- hme_key_metrics.sql
-- Complete Patient-Level & Aggregate Behavior Analysis in SQL

-- 0. Source data: replace the query below with your own extraction logic
WITH source_data AS (
  -- e.g. SELECT PATIENTID, ORDERNUMBER, HCPCS, SERVICEDATEOFORDER, ELIGIBLETOSHIP,
  --       SUPPLYDURATION, TOTALAMOUNT, TOTALQTY, INSURANCE, PATIENT_GROUP, ITEM_GROUP
  SELECT * FROM ORDERS  -- << replace this with your source query >>
),

-- 1. Descriptive RFM + tenure + static attributes
--    One row per patient
descriptive AS (
  SELECT
    PATIENTID,
    MIN(SERVICEDATEOFORDER) AS FIRST_SERVICE_DATE,
    MAX(SERVICEDATEOFORDER) AS LAST_SERVICE_DATE,
    COUNT(DISTINCT ORDERNUMBER) AS ORDERS_TOTAL,
    SUM(TOTALAMOUNT)          AS TOTAL_REVENUE,
    SUM(TOTALQTY)             AS TOTAL_QTY,
    MAX_BY(INSURANCE, SERVICEDATEOFORDER)    AS INSURANCE,
    MAX_BY(PATIENT_GROUP, SERVICEDATEOFORDER) AS PATIENT_GROUP,
    MAX_BY(ITEM_GROUP, SERVICEDATEOFORDER)    AS ITEM_GROUP
  FROM source_data
  GROUP BY PATIENTID
),

-- 2. Order-level lag & on-time flags
order_intervals AS (
  SELECT
    sd.PATIENTID,
    sd.ORDERNUMBER,
    sd.SERVICEDATEOFORDER,
    LAG(sd.SERVICEDATEOFORDER) OVER (PARTITION BY sd.PATIENTID ORDER BY sd.SERVICEDATEOFORDER) AS PREV_DATE,
    LAG(sd.ELIGIBLETOSHIP)   OVER (PARTITION BY sd.PATIENTID ORDER BY sd.SERVICEDATEOFORDER) AS PREV_ELIGIBLE,
    sd.SUPPLYDURATION,
    sd.TOTALAMOUNT,
    DATEDIFF('day', LAG(sd.SERVICEDATEOFORDER) OVER (PARTITION BY sd.PATIENTID ORDER BY sd.SERVICEDATEOFORDER), sd.SERVICEDATEOFORDER) AS DAYS_BETWEEN,
    DATEDIFF('day', LAG(sd.ELIGIBLETOSHIP)     OVER (PARTITION BY sd.PATIENTID ORDER BY sd.SERVICEDATEOFORDER), sd.SERVICEDATEOFORDER) AS DAYS_AFTER_ELIGIBLE,
    CASE
      WHEN DATEDIFF('day', LAG(sd.ELIGIBLETOSHIP) OVER (PARTITION BY sd.PATIENTID ORDER BY sd.SERVICEDATEOFORDER), sd.SERVICEDATEOFORDER)
           BETWEEN 0 AND sd.SUPPLYDURATION * 0.1
      THEN 1
      ELSE 0
    END AS ON_TIME_FLAG
  FROM source_data sd
),

-- 3. Aggregate order-level metrics per patient
order_metrics AS (
  SELECT
    PATIENTID,
    AVG(DAYS_BETWEEN)                                                                 AS AVG_DAYS_BETWEEN,
    AVG(CASE WHEN DAYS_AFTER_ELIGIBLE > 0 THEN DAYS_AFTER_ELIGIBLE ELSE NULL END)        AS AVG_DAYS_LATE,
    SUM(ON_TIME_FLAG)                                                                 AS ON_TIME_ORDERS,
    COUNT(ORDERNUMBER)                                                                AS TOTAL_ORDERS,
    SUM(TOTALAMOUNT)                                                                  AS REVENUE_ORDERS
  FROM order_intervals
  WHERE PREV_DATE IS NOT NULL
  GROUP BY PATIENTID
),

-- 4. Churn flag (1 = churned)
last_supply AS (
  SELECT PATIENTID, MAX(SUPPLYDURATION) AS LAST_SUPPLY_DURATION
  FROM source_data
  GROUP BY PATIENTID
),
churn AS (
  SELECT
    d.PATIENTID,
    CASE WHEN DATEDIFF('day', d.LAST_SERVICE_DATE, CURRENT_DATE()) > ls.LAST_SUPPLY_DURATION * 1.1
         THEN 1 ELSE 0 END AS CHURN_FLAG
  FROM descriptive d
  LEFT JOIN last_supply ls USING(PATIENTID)
),

-- 5. Time to first reorder
second_order AS (
  SELECT
    PATIENTID,
    MIN(SERVICEDATEOFORDER) KEEP (DENSE_RANK SECOND ORDER BY SERVICEDATEOFORDER) AS SECOND_DATE
  FROM source_data
  GROUP BY PATIENTID
),
time_to_first AS (
  SELECT
    d.PATIENTID,
    DATEDIFF('day', d.FIRST_SERVICE_DATE, so.SECOND_DATE) AS TIME_TO_FIRST_REORDER
  FROM descriptive d
  LEFT JOIN second_order so USING(PATIENTID)
),

-- 6. LTV curves
ltv_prep AS (
  SELECT
    sd.PATIENTID,
    sd.SERVICEDATEOFORDER,
    sd.TOTALAMOUNT,
    d.FIRST_SERVICE_DATE
  FROM source_data sd
  JOIN descriptive d USING(PATIENTID)
),
ltv AS (
  SELECT
    PATIENTID,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <=  30 THEN TOTALAMOUNT ELSE 0 END) AS LTV_30d,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <=  60 THEN TOTALAMOUNT ELSE 0 END) AS LTV_60d,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <=  90 THEN TOTALAMOUNT ELSE 0 END) AS LTV_90d,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <= 180 THEN TOTALAMOUNT ELSE 0 END) AS LTV_180d,
    SUM(CASE WHEN DATEDIFF('day', FIRST_SERVICE_DATE, SERVICEDATEOFORDER) <= 365 THEN TOTALAMOUNT ELSE 0 END) AS LTV_365d
  FROM ltv_prep
  GROUP BY PATIENTID
),

-- 7. Basket composition
distinct_items AS (
  SELECT PATIENTID, COUNT(DISTINCT HCPCS) AS UNIQUE_HCPCS
  FROM source_data
  GROUP BY PATIENTID
),

-- 8. Seasonality
distinct_months AS (
  SELECT
    PATIENTID,
    COUNT(DISTINCT DATE_TRUNC('month', SERVICEDATEOFORDER)) AS ACTIVE_MONTHS
  FROM source_data
  GROUP BY PATIENTID
),

-- 9. Assemble full patient metrics
patient_metrics AS (
  SELECT
    d.PATIENTID,
    d.INSURANCE,
    d.PATIENT_GROUP,
    d.ITEM_GROUP,
    d.FIRST_SERVICE_DATE,
    d.LAST_SERVICE_DATE,
    DATEDIFF('day', d.FIRST_SERVICE_DATE, CURRENT_DATE()) AS TENURE_DAYS,
    DATEDIFF('day', d.LAST_SERVICE_DATE,  CURRENT_DATE()) AS RECENCY_DAYS,
    d.ORDERS_TOTAL,
    d.TOTAL_REVENUE,
    d.TOTAL_QTY,
    om.AVG_DAYS_BETWEEN,
    om.AVG_DAYS_LATE,
    om.ON_TIME_ORDERS,
    om.TOTAL_ORDERS,
    om.REVENUE_ORDERS,
    CASE WHEN om.TOTAL_ORDERS > 0 THEN om.ON_TIME_ORDERS::DOUBLE / om.TOTAL_ORDERS ELSE 0 END AS ON_TIME_RATE,
    c.CHURN_FLAG,
    tf.TIME_TO_FIRST_REORDER,
    l.LTV_30d, l.LTV_60d, l.LTV_90d, l.LTV_180d, l.LTV_365d,
    di.UNIQUE_HCPCS,
    dm.ACTIVE_MONTHS
  FROM descriptive d
  LEFT JOIN order_metrics om USING(PATIENTID)
  LEFT JOIN churn c           USING(PATIENTID)
  LEFT JOIN time_to_first tf  USING(PATIENTID)
  LEFT JOIN ltv l             USING(PATIENTID)
  LEFT JOIN distinct_items di USING(PATIENTID)
  LEFT JOIN distinct_months dm USING(PATIENTID)
)

-- 10. Create patient behavior metrics table
CREATE OR REPLACE TABLE PATIENT_BEHAVIOR_METRICS AS
SELECT
  *,
  CASE
    WHEN AVG_DAYS_LATE <=  3 THEN '0-3 days late'
    WHEN AVG_DAYS_LATE <=  7 THEN '4-7 days late'
    WHEN AVG_DAYS_LATE <= 14 THEN '8-14 days late'
    WHEN AVG_DAYS_LATE <= 30 THEN '15-30 days late'
    WHEN AVG_DAYS_LATE <= 60 THEN '31-60 days late'
    WHEN AVG_DAYS_LATE <= 90 THEN '61-90 days late'
    ELSE '>90 days late'
  END AS DAYS_LATE_BUCKET
FROM patient_metrics;

-- 11. Monthly behavior trends (last 24 months)
WITH order_intervals_month AS (
  SELECT
    sd.*,
    LAG(sd.ELIGIBLETOSHIP) OVER (PARTITION BY sd.PATIENTID ORDER BY sd.SERVICEDATEOFORDER) AS PREV_ELIGIBLE
  FROM source_data sd
)
CREATE OR REPLACE TABLE MONTHLY_BEHAVIOR_TRENDS AS
SELECT
  DATE_TRUNC('month', o.SERVICEDATEOFORDER) AS MONTH,
  COUNT(DISTINCT o.PATIENTID) AS ACTIVE_PATIENTS,
  COUNT(o.ORDERNUMBER)        AS TOTAL_ORDERS,
  AVG(DATEDIFF('day', om.PREV_ELIGIBLE, o.SERVICEDATEOFORDER)) AS AVG_DAYS_LATE,
  SUM(CASE WHEN DATEDIFF('day', om.PREV_ELIGIBLE, o.SERVICEDATEOFORDER) BETWEEN 0 AND o.SUPPLYDURATION*0.1
           THEN 1 ELSE 0 END)::DOUBLE / COUNT(*) AS ON_TIME_RATE,
  SUM(o.TOTALAMOUNT)          AS TOTAL_REVENUE
FROM order_intervals_month om
JOIN source_data o USING(ORDERNUMBER)
WHERE o.SERVICEDATEOFORDER >= DATEADD(month, -24, CURRENT_DATE())
GROUP BY 1
ORDER BY 1;
```
