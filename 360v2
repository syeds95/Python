```python
# hme_key_metrics_pandas.py
# Patient-Level & Aggregate Behavior Analysis using pandas & numpy
# Works on pandas DataFrame `my_df` and prints results at the end

import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# Assume `my_df` is a pandas DataFrame with columns:
# PATIENTID, ORDERNUMBER, HCPCS, SERVICEDATEOFORDER (datetime), ELIGIBLETOSHIP (datetime),
# SUPPLYDURATION (numeric days), TOTALAMOUNT, TOTALQTY, INSURANCE, PATIENT_GROUP, ITEM_GROUP

df = my_df.copy()
# Ensure dates are datetime
df['SERVICEDATEOFORDER'] = pd.to_datetime(df['SERVICEDATEOFORDER'])
df['ELIGIBLETOSHIP'] = pd.to_datetime(df['ELIGIBLETOSHIP'])
today = pd.to_datetime(datetime.today().date())

# 1. Descriptive RFM + tenure + static attributes
desc = df.groupby('PATIENTID').agg(
    FIRST_SERVICE_DATE=('SERVICEDATEOFORDER','min'),
    LAST_SERVICE_DATE=('SERVICEDATEOFORDER','max'),
    ORDERS_TOTAL=('ORDERNUMBER','nunique'),
    TOTAL_REVENUE=('TOTALAMOUNT','sum'),
    TOTAL_QTY=('TOTALQTY','sum')
)
# static attrs: take last row per patient
last = df.sort_values('SERVICEDATEOFORDER').groupby('PATIENTID').tail(1)[
    ['PATIENTID','INSURANCE','PATIENT_GROUP','ITEM_GROUP']
].set_index('PATIENTID')
desc = desc.join(last)
# tenure & recency
desc['TENURE_DAYS'] = (today - desc['FIRST_SERVICE_DATE']).dt.days
desc['RECENCY_DAYS'] = (today - desc['LAST_SERVICE_DATE']).dt.days

# 2. Order-level metrics: dedupe and lag
orders = df.drop_duplicates(subset=['ORDERNUMBER'])
orders = orders.sort_values(['PATIENTID','SERVICEDATEOFORDER'])
orders[['PREV_DATE','PREV_ELIGIBLE']] = orders.groupby('PATIENTID')[['SERVICEDATEOFORDER','ELIGIBLETOSHIP']].shift(1)
orders = orders.dropna(subset=['PREV_DATE','PREV_ELIGIBLE'])
orders['DAYS_BETWEEN'] = (orders['SERVICEDATEOFORDER'] - orders['PREV_DATE']).dt.days
orders['DAYS_AFTER_ELIGIBLE'] = (orders['SERVICEDATEOFORDER'] - orders['PREV_ELIGIBLE']).dt.days
orders['ON_TIME_FLAG'] = np.where(
    (orders['DAYS_AFTER_ELIGIBLE'] >= 0) &
    (orders['DAYS_AFTER_ELIGIBLE'] <= orders['SUPPLYDURATION'] * 0.1), 1, 0
)
ord_metrics = orders.groupby('PATIENTID').agg(
    AVG_DAYS_BETWEEN=('DAYS_BETWEEN','mean'),
    AVG_DAYS_LATE=('DAYS_AFTER_ELIGIBLE', lambda x: np.mean(x[x>0]) if len(x[x>0])>0 else 0),
    ON_TIME_ORDERS=('ON_TIME_FLAG','sum'),
    TOTAL_ORDERS=('ORDERNUMBER','count'),
    REVENUE_ORDERS=('TOTALAMOUNT','sum')
)

# 3. Churn flag
last_supply = orders.groupby('PATIENTID')['SUPPLYDURATION'].max().rename('LAST_SUPPLY_DURATION')
desc = desc.join(last_supply, how='left')
desc['CHURN_FLAG'] = np.where(desc['RECENCY_DAYS'] > desc['LAST_SUPPLY_DURATION'] * 1.1, 1, 0)

# 4. Time to first reorder
def second_date(g):
    dates = g['SERVICEDATEOFORDER'].sort_values()
    return dates.iloc[1] if len(dates)>1 else pd.NaT
sec = df.groupby('PATIENTID').apply(second_date).rename('SECOND_DATE')
tf = desc.join(sec)
tf['TIME_TO_FIRST_REORDER'] = (tf['SECOND_DATE'] - tf['FIRST_SERVICE_DATE']).dt.days

# 5. LTV curves
orders_with_first = df.join(desc['FIRST_SERVICE_DATE'], on='PATIENTID')
for d in [30,60,90,180,365]:
    orders_with_first[f'LTV_{d}d'] = np.where(
        (orders_with_first['SERVICEDATEOFORDER'] - orders_with_first['FIRST_SERVICE_DATE']).dt.days <= d,
        orders_with_first['TOTALAMOUNT'], 0
    )
ltv = orders_with_first.groupby('PATIENTID')[[f'LTV_{d}d' for d in [30,60,90,180,365]]].sum()

# 6. Basket composition
distinct_items = df.groupby('PATIENTID')['HCPCS'].nunique().rename('UNIQUE_HCPCS')

# 7. Seasonality
distinct_months = df.assign(
    MONTH=lambda x: x['SERVICEDATEOFORDER'].dt.to_period('M')
).groupby('PATIENTID')['MONTH'].nunique().rename('ACTIVE_MONTHS')

# 8. Assemble patient DataFrame
patient = desc.join(ord_metrics).join(tf['TIME_TO_FIRST_REORDER']).join(ltv).join(distinct_items).join(distinct_months)
patient['ON_TIME_RATE'] = np.where(patient['TOTAL_ORDERS']>0, patient['ON_TIME_ORDERS']/patient['TOTAL_ORDERS'], 0)
# days late bucket
patient['DAYS_LATE_BUCKET'] = pd.cut(
    patient['AVG_DAYS_LATE'], bins=[-1,3,7,14,30,60,90,np.inf],
    labels=["0-3","4-7","8-14","15-30","31-60","61-90",">90"]
)

# 9. Print patient-level table
print("=== Patient-Level Metrics ===")
print(patient.reset_index().head(10))

# 10. Group rollups
for grp in ['PATIENT_GROUP','ITEM_GROUP','INSURANCE','DAYS_LATE_BUCKET']:
    grp_tbl = patient.reset_index().groupby(grp).agg(
        AVG_TENURE_DAYS=('TENURE_DAYS','mean'),
        AVG_RECENCY_DAYS=('RECENCY_DAYS','mean'),
        AVG_FREQ_PER_PATIENT=('ORDERS_TOTAL','mean'),
        AVG_REV_PER_PATIENT=('TOTAL_REVENUE','mean'),
        AVG_DAYS_BETWEEN_ORDERS=('AVG_DAYS_BETWEEN','mean'),
        AVG_DAYS_LATE=('AVG_DAYS_LATE','mean'),
        AVG_ON_TIME_RATE=('ON_TIME_RATE','mean'),
        PATIENT_COUNT=('PATIENTID','count')
    ).reset_index()
    print(f"=== Rollup by {grp} ===")
    print(grp_tbl)

# 11. Monthly trends
o = orders.copy()
o['MONTH'] = o['SERVICEDATEOFORDER'].dt.to_period('M').dt.to_timestamp()
o = o[o['MONTH'] >= (today - pd.DateOffset(months=24))]
monthly = o.groupby('MONTH').agg(
    ACTIVE_PATIENTS=('PATIENTID', lambda x: x.nunique()),
    TOTAL_ORDERS=('ORDERNUMBER','count'),
    AVG_DAYS_LATE=('DAYS_AFTER_ELIGIBLE','mean'),
    ON_TIME_RATE=('ON_TIME_FLAG',lambda x: x.sum()/len(x) if len(x)>0 else 0),
    TOTAL_REVENUE=('TOTALAMOUNT','sum')
).reset_index()
print("=== Monthly Behavior Trends ===")
print(monthly)
```
